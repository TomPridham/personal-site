<!DOCTYPE html><head><meta charset="utf8"><meta lang="en-US"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="tom pridham"><meta name="description" content="portfolio site for tom pridham. he likes being good at things."><title>tompridham.me </title><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/app.css"></head><body><div id="header" class="space-between"><a id="home" href="/"><span>tompridham.me</span></a><ul id="menu"><li><a id="cv" href="/cv">cv</a></li><li><a id="about" href="/about">about</a></li><li><a id="blog" href="/blog">blog</a></li><li><a id="projects" href="/projects">projects</a></li><li><a href="https://github.com/tompridham">github</a></li></ul></div><div id="container"><h1>a/b testing with cloudflare workers</h1><p>at my current job(pdq.com), we had been wanting to implement a/b testing for our marketing site. because our site is server side rendered and we were sending down fully formed html on each request this was trickier than it might have otherwise been. the easiest method is to replace content at runtime based on a feature flag fetched from an api.</p><pre><div class="code"><code>
const featureFlag = await getFlagFromApi()
...
return (
    &lt;div&gt;
        {featureFlag === &quot;feature-flag-a&quot; &amp;&amp; &lt;p&gt;a content&lt;p&gt;}
        {featureFlag === &quot;feature-flag-b&quot; &amp;&amp; &lt;p&gt;b content&lt;p&gt;}
    &lt;/div
)
</code></div></pre><p>this would have resulted in content popping in or shifting once the api finally resolved, which made it a non-starter. the other method that we saw commonly in articles online was to introduce an artificial delay to allow the request to resolve before actually displaying anything ðŸ¤®.</p><pre><div class="code"><code>
const featureFlag = await getFlagFromApi()
...
return (
    &lt;div&gt;
        {!featureFlag &amp;&amp; &lt;div class=&quot;full-screen-loading-screen&quot; /&gt;}
        {featureFlag === &quot;feature-flag-a&quot; &amp;&amp; &lt;p&gt;a content&lt;p&gt;}
        {featureFlag === &quot;feature-flag-b&quot; &amp;&amp; &lt;p&gt;b content&lt;p&gt;}
    &lt;/div
)
</code></div></pre><p>both those options were undesirable because they would negatively affect our users and would negate most of the benefits of server side rendering. the other option we saw that was tailored to work with server side rendered sites require maintaining a long lived branch for each a/b test. since the amount of traffic our site gets is relatively small, our tests would be running for multiple weeks. having multiple feature branches would require a lot of work to keep them up to date and also to redeploy them whenever our content team published a new article ðŸ˜©. thus began the quest for a sustainable a/b testing solution that would work with minimal maintenance from us.</p><p>it seemed like any good solution would require us to build our site once for each feature flag. so we got to work implementing that. initially we hardcoded multiple builds into our pipeline and had the builds deployed to our kubernetes cluster at different routes. now we just needed to figure out how to route people to them.</p><p>a dynamic routing solution that is tailored to kubernetes workloads seemed like a good path to start down. lo and behold, there is a solution that promised just that! there were some tutorials online that even showed our exact a/b testing use case! so i asked our devops team to implement an istio service mesh. eventually they thought it was in a good working state, so we rolled it out. a couple of days later we started getting reports of weird, intermittent errors. the worst kind of error!</p><p>fast forward past a couple of days of 'it works on my machine', we finally discovered the cause. the istio routing wasn't respecting the cookie we had set to ensure people would get routed to the same pod every time. so, for their first request they might get sent to feature-flag-a.pdq.com and get the index.html, this html would then request `feature-flag-a-some-hash.js` which would sometimes resolve to the correct pod and would sometimes 404 because it was going to the wrong pod. the inherent randomness was due to the routing rules we had to assign people to buckets randomly initially. so 50% would get featureFlagA and 50% would get featureFlagB. which would be correct if the requests were sticky so that once someone got featureFlagA they ALWAYS got featureFlagA. our devops team wasn't sure what the error was and wasn't sure when they were going to be able to get back to fix it, so it was back to the drawing board for us.</p><p>we have a pretty slick setup for our dev environment that automatically creates a dns record, new kubernetes workspace, and deploys a build to that workspace whenever a pull request is opened or new commits are pushed to the pull request. this has worked really well for our internal testing and we had worked out most of the issues already. so we thought that we could leverage similar logic to get our to our desired a/b testing state. adapting the logic to work for a/b testing was pretty easy. basically just read an environment variable and run the build/deploy pipeline once for each | separated feature flag.</p><p>so, now we had multiple versions of our site being built and deployed based on our google optimize feature flags. we just needed to figure out how to direct people to the correct pod while obfuscating the fact that they were really accessing something like asdflkbeubfdf-1.ab.pdq.com.</p><p>we use cloudflare for our dns and to manage redirects for a variety of use cases. they also offer a service they call 'workers' that is basically just a serverless function that sits in front of their dns servers. that seemed like the perfect opportunity to consolidate the mishmash of one off redirects and get us a/b testing. as an added bonus this would let us remove a bunch of untestable rules and add tests for the rest of the existing redirects. so we got started replacing the redirects and adding tests(such a big spook that there weren't any to begin with ðŸ‘») for existing ones. once that was working, it was time to implement the a/b testing functionality.</p><p>the actual a/b testing logic in the worker is pretty simple. it's something like this</p><pre><div class="code"><code>
let featureFlag = getCookies('feature-flag')
if (!featureFlag){
    featureFlag = assignFlagBasedOnWeights()
    res.headers.append('Set-Cookie', `feature-flag=${featureFlag}`)
}
return fetch(`${featureFlag}.ab.pdq.com`)
</code></div></pre><p>there is some more logic that handles some normalization tasks and other business requirements, but that's the meat of it. now whenever that person visits our site all their requests should get routed to the same bucket. and when our content team publishes something or we merge new code to main, it will trigger our normal deploy process and automatically be deployed to all the different pods! now we can finally test changes to actually confirm they are beneficial instead of just someone being like 'feels better to me'.</p></div><script type="text/javascript">
    const active = document
      .querySelector('.active-header');
    if(active){
      active.classList.remove('active-header');
    }
    document
      .getElementById('blog/a_b_testing_with_cloudflare_workers'.split('/')[0])
      .classList
      .add('active-header')
</script></body>