extern crate maud;

use maud::{html, Markup};

pub fn windows_data_with_actors() -> Result<Markup, Box<dyn std::error::Error>> {
    let h = html! {
        h1{"getting windows event data with actors"}
        p{
            "i have been a proponent of the rust programming language for a few years and have pitched using it at my jobs. my current work(pdq.com) has a project that would be perfect for it and i was able to convince our engineering department that we should give it a shot. so far, it's been pretty successful and has been well recieved. the main issues we have run into so far have been around using the windows-rs crate. which is an autogenerated api that has limited documentation, very little of it rust specific. i figured i would document some of the trickier things we ended up having to do in case it helps someone else."
        }
        p{
            "one of the things that we needed to do was to subscribe to and report windows events. should be easy right? let's go look at the documentation for it. EventLog sounds like a promising start. "
                a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/EventLog/index.html"{"hmm..."}
            " like, 200 items and not a lick of documentation. let's see if we can find some actual documentation on microsoft's site. there isn't any direct mapping between the rust crate and the official documentation that i can discern, but i was able to find "
                a href="https://docs.microsoft.com/en-us/windows/win32/wes/subscribing-to-events"{"this"}
            " by searching `windows eventlog`. which led me to the corresponding "
                a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/EventLog/fn.EvtSubscribe.html" {"rust function"}
            ". which has the following signature"
        }
        pre{
            div.code{
                code{
r#"
pub unsafe fn EvtSubscribe<'a, Param1: IntoParam<'a, HANDLE>, Param2: IntoParam<'a, PWSTR>, Param3: IntoParam<'a, PWSTR>>(
    session: isize,
    signalevent: Param1,
    channelpath: Param2,
    query: Param3,
    bookmark: isize,
    context: *const c_void,
    callback: Option<EVT_SUBSCRIBE_CALLBACK>,
    flags: u32
) -> isize
"#
                }
            }
        }
        p{
            "🧐 ok, not terribly helpful. let's see if we can decipher what some of this is supposed to do."
        }
        p{
            "according to the documentation it is a session handle to a remote session. if we want to subscribe to local events it should be NULL. since isize can't be null, lets set it to 0 for now. so far we have: "
        }
        pre{
            div.code{
                code{
r#"
let session = 0_isize;
unsafe {
    EventLog::EvtSubscribe(
        session,
        ...
    );
}
"#
                }
            }
        }
        p{
            "the next parameter is `signalevent`, which needs to be NULL if we are going to pass a callback, which we are going to do. ez. next is the channelpath, which is the event channel we want to subscribe to. we can get a list of event channels by running the following powershell"
        }
        pre{
            div.code{
                code{
r#"
Get-WinEvent -ListLog *
"#
                }
            }
        }
        p{
            "we are going to use the `Security` channel because it includes the logged in and logged off events and those are easy to generate. the next piece we need is `query`, which needs to be a structured xml query(ew). a list of event codes can be found "
                a href="https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/"{"here"}". so the two codes we're going to use are 4624 and 4634. our code now looks like"
        }
        pre{
            div.code{
                code{
r#"
let session = 0_isize;
let signal_event = None;
let channel_path = "Security";
let query = "EventID=4624 or EventID=4634";
unsafe {
    EventLog::EvtSubscribe(
        session,
        signal_event,
        channel_path,
        query
        ...
    );
}
"#
                }
            }
        }
        p{
            "the next parameter is `bookmark`, which is only required if the flags parameter that is last contains the `EvtSubscribeStartAfterBookmark` flag, otherwise it should be NULL. since we aren't going to be using that flag we can set it to 0 the same as the session! next we have `context` which is used to communicate between the callback we are going to provide and the rest of our program. we're going to skip over this for now and just use `std::ffi::null_mut`. next we need a callback, which is a function of the following form"
        }
        pre{
            div.code{
                code{
r#"
pub type EVT_SUBSCRIBE_CALLBACK = unsafe extern "system" fn(action: EVT_SUBSCRIBE_NOTIFY_ACTION, usercontext: *const c_void, event: isize) -> u32;
"#
                }
            }
        }
        p{
            "the first parameter here is an "
                a href="https://docs.microsoft.com/en-us/windows/win32/api/winevt/ne-winevt-evt_subscribe_notify_action"{"enum"}
                " that is basically `Result`, it indicates whether there was an error or if there is a notification. that's pretty easy to take care of. we can just check if it's and error and exit early if so. the second param is the context, which is the `null_mut` pointer we made earlier. we're still gonna ignore it for now. the last one is the event handle which we will pass to another `EventLog` api to fetch the actual event, but we'll come back to that. let's stub out the callback function first. something important to note is the `#[no_mangle]` attribute. this tells rust to leave the function name as is so that it can be referenced by outside code correctly. we found some odd behavior where the mangling behavior was only breaking things when building the release version for `x86_64-pc-windows-msvc`. when i built the release version on my linux laptop for the `x86_64-pc-windows-gnu` toolchain, everything worked as expected. but when my coworkers built it on their windows machine using the msvc target, the program would crash as soon as an event fired."
        }
        pre{
            div.code{
                code{
r#"
#[no_mangle]
extern "system" fn event_callback(
    action: EventLog::EVT_SUBSCRIBE_NOTIFY_ACTION,
    p_context: *const c_void,
    h_event: isize,
) -> u32 {
    if action == EventLog::EvtSubscribeActionError {
        eprintln!("Error in the subscriber: {:?}", action);
        return 1;
    }
    0
}
"#
                }
            }
        }
        p{
            "okay, now we are quitting early if there is an error and returning a 0 for success otherwise. now we need to do something to get the actual event data. we need to use the "
                a href="https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/EventLog/fn.EvtRender.html"{"EvtRender"}
            " api. the first param is context, which should be NULL if the third param is `EventLog::EvtRenderEventXml`, which is what we want, so we will set it to 0. in our case, the second param is the event handle. the third param will be `EvtRenderEventXml` so that we get the full XML object back. `EvtRenderEventXml` is a newtype tuple wrapper over an i32, so we actually want `EvtRenderEventXml.0`. the fourth param is the buffer size in bytes, which we're going to set at an arbitrary 65000 bytes because that should be far larger than any events. if the buffer is not large enough, the function will fail, but we're going to assume that will be large enough for now. next we need a buffer which is just a pointer to an array. the second to last param will be the amount of bytes actually used by the event and the last won't be used because we are getting the full xml object, we can set both to 0. putting all that together we end up with our callback looking like this"
        }
        pre{
            div.code{
                code{
r#"
#[no_mangle]
extern "system" fn event_callback(
    action: EventLog::EVT_SUBSCRIBE_NOTIFY_ACTION,
    p_context: *const c_void,
    event_handle: isize,
) -> u32 {
    if action == EventLog::EvtSubscribeActionError {
        eprintln!("Error in the subscriber: {:?}", action);
        return 1;
    }

    let render_context = 0;
    const BUFFER_SIZE: usize = 65_000;
    // windows use UTF16 for their strings which means that their strings are 16 bytes wide
    // instead of the normal 8 for rust's UTF8 strings
    let mut buffer: [u16; BUFFER_SIZE] = [0; BUFFER_SIZE];
    let buffer_ptr = buffer.as_mut_ptr() as *mut c_void;
    let mut used_buffer = 0;
    let mut property_count = 0;

    unsafe {
        EventLog::EvtRender(
            render_context,
            event_handle,
            EventLog::EvtRenderEventXml.0 as u32,
            BUFFER_SIZE as u32,
            buffer_ptr,
            &mut used_buffer,
            &mut property_count,
        );
    }

    0
}
"#
                }
            }
        }
        p{
            "whew. okay, we are almost to a point where we can actually look at the events! all we need to do is turn the buffer into a string. luckily, that part is relatively easy. rust has some nice std methods that make turning a byte vec into a string easy. because the windows-rs crate is just a wrapper over the C apis, the event xml string is ended with a null terminator byte which we need to remove."
        }
        pre{
            div.code{
                code{
r#"
#[no_mangle]
extern "system" fn event_callback(
    action: EventLog::EVT_SUBSCRIBE_NOTIFY_ACTION,
    p_context: *const c_void,
    event_handle: isize,
) -> u32 {
    // snip
    // take a slice of only the used buffer, then turn that into a string
    let s = String::from_utf16(&buffer).unwrap_or_default();
    println!("{}", s);
    0
}
"#
                }
            }
        }
        p{
            "now that we have that out of the way, we can finish our subscribe function from above. the last param we need to provide is `flags`, which is an enum that maps to a u32. it describes when we should start subscribing to events. there are a few possible "
            a href="https://docs.microsoft.com/en-us/windows/win32/api/winevt/ne-winevt-evt_subscribe_flags"{"values"}
            ". we are only interested in future events, so we will use `EventLog::EvtSubscribeToFutureEvents`. now we can put everything together and try this out."
        }
        pre{
            div.code{
                code{
r#"
let session = 0;
let signal_event = None;
let channel_path = "Security";
let query = "EventID=4624 or EventID=4634";
let bookmark = 0;
let context = std::ptr::null_mut();
let flags: u32 = EventLog::EvtSubscribeToFutureEvents.0 as u32;
unsafe {
    EventLog::EvtSubscribe(
        session,
        signal_event,
        channel_path,
        query
        bookmark,
        context,
        Some(event_callback),
    );
}
"#
                }
            }
        }
        p{
            "you should see a very large xml string printed to the console. hooray! this is only mildly useful however. we need to get that information back to our main rust program so that we can do something with it besides print it to our local terminal. this is getting pretty long so i will be breaking it up into multiple "
                a href="/blog/windows_data_with_actors_2"{"parts"}
                ". i'll end this part here."
        }
    };
    Ok(h)
}
